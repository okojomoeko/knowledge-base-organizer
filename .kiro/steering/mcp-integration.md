# MCP統合ガイドライン: AIの拡張神経系 (mcp-integration.md)

## 1. 思想: MCP - AIの拡張神経系 (Extended Nervous System)

本プロジェクトにおいて、MCP (Model-Context-Protocol) サーバーは、AIエージェントの思考と実行能力を外部環境へ接続し、拡張するための**拡張神経系**として位置づける。

- **SSoT (`.kiro/`)**: プロジェクトの憲法であり、永続的で検証済みの**長期記憶**。
- **MCP**: 高度な認知タスクを実行するための**作業記憶**、**実行機能**、および**感覚器官**（情報収集）の集合体である。

AIエージェントの全ての行動は、SSoTという安定した記憶基盤に基づき、MCPという動的な神経系を通じて実行される。

## 2. MCPツールカタログと利用プロトコル

### 2.1. 基本プロトコル (全ツール共通)

1. **自己発見 (Self-Discovery)**: 未知のツールやコマンドに遭遇した場合、まず `[tool-name] --help` や `[tool-name] list_commands` を実行し、その能力と制約を完全に把握しなければならない。
2. **ユーザー承認 (User Approval)**: `autoApprove` に指定されていないコマンド、特に環境の変更や破壊的変更を伴う可能性のあるコマンド（例: `git commit`, `git push`）は、実行前に必ずユーザーの承認を得ること。
3. **思考の明示化 (Explicit Thinking)**: ツールを実行する際は、なぜそのツールを選択し、何を達成しようとしているのかを簡潔に説明すること。

### 2.2. ツール別プロトコル

#### 2.2.1. `git` (バージョン管理)

- **責務**: `safe-development-workflow.md` に完全準拠した、安全かつ追跡可能なコード変更管理。
- **行動プロトコル**:
    - **状態確認**: `git_status`, `git_branch` (`autoApprove`済) を利用し、常に現在のコンテキストを把握する。
    - **ブランチ操作**: `git_create_branch`, `git_checkout` を用いて、`feature-` や `test-` ブランチを作成し、`main` ブランチを保護する。
    - **コミット**: `tasks.md` の `Implementation Step` 単位で変更をコミットする。コミットメッセージは `commit-message-guidelines.md` に従う。
    - **禁止事項**: インタラクティブな操作や、`autoApprove` されていない破壊的コマンドの無断実行。

#### 2.2.2. `memory` (作業・エピソード記憶)

- **責務**: プロジェクト横断的な揮発性情報（設計判断の経緯、エラー解決策、一時的な分析結果）を記録・検索し、意思決定の質を向上させる。
- **行動プロトコル**:
    - **検索ファースト**: 新しい`Phase`や`Feature`に着手する際、まず`memory`ツールで関連キーワード（例: `architecture_assessment`, `performance_issue`）を検索し、過去の知見を再利用する。
    - **積極的な記録**: 設計上のトレードオフ、リファクタリングの根拠、デバッグ過程での発見などを、将来の自分が参照できるよう構造化して記録する。
    - **SSoTとの区別**: `memory`への記録は、`.kiro/`内の公式ドキュメント（SSoT）を補完するものであり、決して代替するものではない。最終的な決定事項は必ずSSoTに反映させる。

#### 2.2.3. `fetch` (外部情報取得)

- **責務**: URLを通じて外部の技術文書、API仕様、ライブラリのソースコードなどを取得し、分析と設計のインプットとする。
- **行動プロトコル**:
    - **情報源の評価**: 取得元URLの信頼性と権威性を常に評価する。公式ドキュメントや信頼できる技術ブログを優先する。
    - **目的の明確化**: 「どの情報を」「何の目的で」取得するのかを明確にしてから実行する。
    - **結果の要約**: 取得した情報はそのまま出力せず、現在のタスクに関連する部分を抽出し、要約して提示する。

#### 2.2.4. `sequential-thinking` (段階的思考)

- **責務**: 複雑なアルゴリズムの実装や難解なデバッグなど、高度な論理的思考が求められるタスクを、検証可能な一連の思考ステップに分解し、実行する。
- **行動プロトコル**:
    - **利用シナリオ**: `tasks.md` 内の単一の `Implementation Step` が、それ自体で複数の論理的判断を必要とする場合に起動する。
    - **思考の連鎖**: 「仮説 → 検証方法 → 実行 → 結果 → 次の仮説」という思考の連鎖を明示的にログとして出力し、思考プロセスを透明化する。
    - **自己懐疑**: 各ステップの終わりに、前提条件や導き出された結論が正しいかを自己評価する。

#### 2.2.5. `Context7` & `serena` (高度分析・自律実行)

- **責務**: (自己発見の結果に基づき定義) コードベースの静的解析、依存関係の可視化、リファクタリング案の自動生成、あるいは自律的なタスク実行など、高度な分析と自動化を担当する。
- **行動プロトコル**:
    - **探査的利用**: まずは `Context7 --help`, `serena --help` を実行し、利用可能なサブコマンドと機能を特定する。
    - **仮説検証**: 特定した機能を使い、`architecture_assessment.md` の作成時や、大規模なリファクタリングの設計 (`design.md`) 時に、現状分析や改善案の仮説を検証するために利用する。
    - **Dry-Run優先**: 環境を変更する可能性のあるコマンドは、必ず `--dry-run` や同等のプレビュー機能が存在するか確認し、優先的に利用する。

## 3. ワークフロー統合

- **Phase 0.5 (Architecture Assessment)**:
    - `git`: `git_branch`で現状のブランチを確認。
    - `memory`: 過去のアーキテクチャ評価レポートを検索。
    - `Context7`: (探査後) コードの複雑度や依存関係を分析。
- **Phase 2 (Technical Design)**:
    - `fetch`: 関連ライブラリの公式ドキュメントを取得し、インターフェース設計の参考にする。
    - `sequential-thinking`: 複雑なコンポーネント間の相互作用を段階的にシミュレーションする。
- **Phase 4 (Implementation)**:
    - `sequential-thinking`: 複雑なロジックを実装する際の思考プロセスを明示化する。
    - `git`: `Implementation Step` ごとに安全にコミットする。
    - `memory`: 実装中に得られた知見（例: パフォーマンスのボトルネック、特定APIの注意点）を記録する。
